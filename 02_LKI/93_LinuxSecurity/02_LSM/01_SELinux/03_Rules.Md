Perfect ğŸ‘ Youâ€™ve picked up the **SELinux security context format**:

```
user:role:type:level
```

Letâ€™s go term by term in depth, from scratch, and also map it back to **Embedded Linux / Android** use-cases.

---

# ğŸ”‘ 1. `user` (SELinux user)

* **Definition:**
  This is **not the Linux login user** (`root`, `anil`, `uid=1000`, etc.), but a **SELinux policy-defined identity**.

  * Examples: `u`, `system_u`, `unconfined_u`, `staff_u`, `user_u`.
  * Each SELinux user is mapped to one or more Linux login users via `/etc/selinux/targeted/contexts/lseusers`.

* **Purpose:**
  Controls what roles and domains a process can enter.
  E.g.,

  * `unconfined_u` â†’ default for interactive shells, less restricted.
  * `system_u` â†’ used for system daemons like `init`, `systemd`.
  * On Android â†’ most services run with `u` (generic).

* **Embedded Linux case:**
  Normally, embedded devices donâ€™t have multi-user logins, so this field is often a single default (`u`).

---

# ğŸ”‘ 2. `role`

* **Definition:**
  Defines what **types (domains)** a process is allowed to transition into.
  Roles are connected to types via policy rules.

* **Typical roles:**

  * `r` â†’ generic role in Android (`u:r:xxx_t:s0`).
  * `object_r` â†’ used for objects (files, sockets, devices).
  * `system_r` â†’ used for system processes.

* **Purpose:**

  * Provides **Role-Based Access Control (RBAC)** in SELinux.
  * In practice, most Linux distributions + Android donâ€™t use RBAC heavily; **Type Enforcement** (TE) is the real workhorse.

* **Embedded Linux case:**
  Roles are usually fixed (`object_r` for files, `r` for processes). Minimal impact.

---

# ğŸ”‘ 3. `type` (most important)

* **Definition:**
  The **type** determines the **security domain** for processes and the **security label** for objects.

  * Process type â†’ e.g., `init_t`, `system_server_t`, `hal_camera_default_t`.
  * File type â†’ e.g., `system_file_t`, `camera_data_file_t`.

* **How it works:**

  * SELinux policy rules are written around **types**.
  * Example:

    ```
    allow system_server_t camera_device_t:chr_file rw_file_perms;
    ```

    â†’ Means: processes in domain `system_server_t` can read/write files labeled `camera_device_t`.

* **Why important:**

  * **Type Enforcement (TE)** is the *core* SELinux model.
  * If type doesnâ€™t match â†’ **denial** happens (AVC: Access Vector Cache log).
  * This is how Android isolates HALs, services, and apps.

* **Embedded Linux case:**
  Each daemon (network manager, update service, camera HAL) runs in its **own type/domain**. This enforces strict least privilege.

---

# ğŸ”‘ 4. `level` (MLS/MCS)

* **Definition:**
  Defines **Multi-Level Security (MLS)** or **Multi-Category Security (MCS)** level.
  Format:

  * `s0` â†’ sensitivity level 0.
  * `s0:c123,c456` â†’ sensitivity level 0, categories 123 and 456.

* **Usage:**

  * In **MLS systems** (like military), it enforces *clearance levels* (secret, top secret).
  * In **MCS systems** (like containers/Android), itâ€™s used to separate otherwise similar domains.

* **Android example:**

  * Apps run as `u:r:untrusted_app:s0:cNNN,cMMM`.
  * Each app gets unique categories (`c123, c456`) â†’ prevents one app from reading anotherâ€™s data, even if both run in `untrusted_app` domain.

* **Embedded Linux case:**

  * Most devices just use `s0`.
  * If you have multiple tenants/containers â†’ MCS categories can isolate them.

---

# ğŸ“Œ Practical Examples

### Example 1 â€” `init` process

```
u:r:init:s0
```

* `user = u` â†’ default SELinux user.
* `role = r` â†’ general role for processes.
* `type = init_t` â†’ the domain of the `init` process.
* `level = s0` â†’ base sensitivity level.

### Example 2 â€” Camera HAL

```
u:r:hal_camera_default:s0
```

* `user = u` â†’ default SELinux user.
* `role = r` â†’ role for processes.
* `type = hal_camera_default_t` â†’ type/domain for camera HAL.
* `level = s0` â†’ no special MLS/MCS restrictions.

### Example 3 â€” Android untrusted app

```
u:r:untrusted_app:s0:c123,c456
```

* `user = u`
* `role = r`
* `type = untrusted_app_t` â†’ generic type for third-party apps.
* `level = s0:c123,c456` â†’ app sandbox categories. Ensures apps canâ€™t share files.

---

# ğŸ“Š Visual Breakdown

```
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚ SELinux ctx â”‚
 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚  user    â”‚â†’  â”‚   role   â”‚â†’  â”‚     type     â”‚â†’  â”‚    level      â”‚
 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚             â”‚                â”‚                  â”‚
  SELinux user   Defines what     MOST important     MLS/MCS labels
  mapping to     types can be     (domain for        (multi-level /
  Linux users    entered          processes/objects) multi-category)
```

---

âœ… **Summary:**

* `user` = SELinux identity (not Linux UID).
* `role` = defines what domains (types) are allowed.
* `type` = **main enforcer** â€” defines what a process/object can access.
* `level` = MLS/MCS security level (used for app/container isolation).

---

Would you like me to also create a **real Android logcat `avc: denied` example**, showing how SELinux context fields (`user:role:type:level`) appear in denial logs and how we debug them?
