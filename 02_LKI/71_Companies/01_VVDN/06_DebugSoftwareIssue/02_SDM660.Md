Absolutely—here’s a **deep, SDM660-specific** debugging & troubleshooting playbook with **ready-to-paste bootargs**, **exact debugfs paths**, and **subsystem checklists** (MMC/SDHCI, IPA/NET, RPM/Clocks/Regulators, SLPI/remoteproc). It’s tuned for BSP/driver bring-up on Snapdragon 660–class boards.

---

# SDM660 Debugging Playbook (Kernel panics, driver failures, hangs)

## 1) Bootargs & always-on debug

Use these to make the kernel talk early and keep symbols stable.

**Kernel cmdline (baseline for bring-up):**

```
console=ttyMSM0,115200n8 earlycon ignore_loglevel loglevel=7 printk.time=1 \
no_console_suspend initcall_debug nokaslr kpti=off
```

* `console=ttyMSM0` → SDM660 UART (keep DT chosen `stdout-path` to that UART).
* `earlycon` → uses DT-provided stdout when possible; if you need explicit:

  * Fallbacks you can try (board-dependent): `earlycon=msm_serial_dm,0x78af000` (legacy BLSP) or `earlycon=qcom_geni,0xA90000` (GENI). Use your board’s UART base from DT.
* `initcall_debug` → timestamps each initcall (great for slow driver probes).
* `nokaslr` → stable addresses for symbolizing oops.
* `kpti=off` only on dev boards (perf/trace clarity); **don’t ship** with it.

**Runtime knobs you’ll reuse:**

```bash
# Magic SysRq for freezes:
echo 1 > /proc/sys/kernel/sysrq

# Dynamic debug globally (then enable per-driver):
echo "module * +p" > /sys/kernel/debug/dynamic_debug/control

# Persist logs across reboot (pstore/ramoops):
mount -t pstore pstore /sys/fs/pstore
```

---

## 2) Where to look on SDM660 (debugfs/sysfs map)

* **Clocks:** `/sys/kernel/debug/clk/clk_summary`
* **Regulators (RPM SMD):** `/sys/kernel/debug/regulator/regulator_summary`
* **GPIO:** `/sys/kernel/debug/gpio`
* **Pinctrl:** `/sys/kernel/debug/pinctrl/<soc>:pinctrl/` (pins & states)
* **I²C:** `/sys/kernel/debug/i2c/` and bus nodes in `/sys/bus/i2c/devices/`
* **SPI:** `/sys/bus/spi/devices/`
* **MMC/SDHCI:** `/sys/kernel/debug/mmc0/` … `ios`, `host`, `regs`, `debugfs`
* **Remoteproc (SLPI/ADSP/MSS):** `/sys/class/remoteproc/remoteproc*/{name,state,traceX}`
* **GLink/RPMsg:** `/sys/kernel/debug/msm_geni_serial/`, `/sys/kernel/debug/rpmsg/`, sometimes `/sys/kernel/debug/glink/`
* **IPA/NET:** `/sys/kernel/debug/ipa/` (if enabled), `/sys/class/net/rmnet_ipa*/statistics`
* **Thermal/CPUfreq:** `/sys/class/thermal/`, `/sys/devices/system/cpu/cpufreq/`
* **Interconnect/devfreq (if enabled):** `/sys/class/devfreq/`, `/sys/kernel/debug/bwmon/`

---

## 3) Fast triage flow (panic, oops, hang)

**When you see a panic/oops:**

1. Save the full trace (serial/pstore).
2. Symbolize addresses with your **matching** build:

   ```bash
   addr2line -e vmlinux 0xffffffff8abc1234
   addr2line -e drivers/<subsys>/<drv>.ko 0x<module-offset>
   ```
3. If memory bugs suspected → rebuild with `CONFIG_KASAN=y kasan=on` (dev build).
4. If intermittent → `CONFIG_KFENCE=y` (low overhead guard).

**When it freezes (no panic):**

```bash
echo t > /proc/sysrq-trigger   # task stacks
echo w > /proc/sysrq-trigger   # blocked tasks
echo l > /proc/sysrq-trigger   # backtraces all CPUs
```

Enable:

```
nmi_watchdog=1 hung_task_panic=1 rcupdate.rcu_cpu_stall_timeout=60
```

If deadlocks/races suspected: `CONFIG_PROVE_LOCKING`, `CONFIG_LOCKDEP`, `CONFIG_KCSAN`.

**Function graph around a suspect driver:**

```bash
echo function_graph > /sys/kernel/debug/tracing/current_tracer
echo 1 > /sys/kernel/debug/tracing/tracing_on
# repro…
cat /sys/kernel/debug/tracing/trace > /tmp/fg.txt
```

---

## 4) SDM660 driver-probe failures (checklist)

1. **DT match**

   * `compatible` matches driver’s `of_match_table`.
   * Node has `status = "okay";`
   * Addresses/clocks/resets/interrupts correct.
2. **Power (RPM SMD) & clocks**

   * `regulator_summary` → rail ON and within µV range.
   * `clk_summary` → core/iface clocks ON during probe.
3. **Reset lines**

   * `reset-gpios` or `resets` deasserted before register access.
4. **Pinctrl**

   * `pinctrl-0` applied, correct mux + bias; check pins in pinctrl debugfs.
5. **Bus layer**

   * I²C: device ACKs? `i2cdetect -y <bus>` (careful). Check `reg=<addr>`.
   * SPI: CPOL/CPHA, `max_speed_hz`, CS gpio polarity (`spi-cs-high` if needed).
6. **Interrupts**

   * Edge/level type matches hardware; GPIO → IRQ mapping valid.
7. **DMA**

   * `dma_set_mask_and_coherent()` matches HW width (often 32-bit on 660 IP).
8. **Probe deferral**

   * Seeing `-EPROBE_DEFER` loops? Missing supplier (clk/reg/phy). Fix DT order or rely on fw\_devlink (recent kernels).

**Turn on driver logs without rebuild:**

```bash
echo 'module <your_module> +p' > /sys/kernel/debug/dynamic_debug/control
dmesg -w
```

---

## 5) Subsystem specifics (SDM660)

### A) MMC/SD (Qualcomm SDHCI)

**Symptoms:** timeouts during init, HS200/HS400 failures, random I/O errors.

* Check:

  * `/sys/kernel/debug/mmc0/ios` and `…/host` for negotiated mode/clock.
  * DT: `bus-width`, `non-removable`, `vqmmc-supply`, `vmmc-supply`, `cap-sd-highspeed`, `mmc-hs200-1_8v`, tuning props.
  * Signal voltage switch (3.3→1.8 V) can fail → test locking to HS/DDR52 first.
* Debug toggles:

  * Bootarg: `mmc_core.debug=0x1`
  * Disable clock gating to test stability: `mmc_core.clock_gating=0`
* Quick tests:

  ```bash
  dd if=/dev/mmcblk0 of=/dev/null bs=1M count=100
  cat /sys/kernel/debug/mmc0/err_stats
  ```

### B) IPA / Networking (rmnet/ipa)

**Path:** Apps CPU ↔ IPA ↔ Modem (QMI/rmnet).

* Verify interfaces: `ip link | grep rmnet`, `ethtool -S rmnet_ipa0`
* If bring-up fails after modem restart:

  * Re-check QMI services up, IPA FW loaded, power domain for IPA enabled.
* Thruput/IRQ issues:

  * Pin IRQ affinity: `echo <mask> > /proc/irq/<n>/smp_affinity`
  * Offloads: GRO/LRO/NAPI budget tuning (`ethtool -K`, sysctls)
* Debugfs (if enabled): `/sys/kernel/debug/ipa/` (pipes, endpoints, stats)

### C) Remoteproc subsystems (ADSP, SLPI, MSS/modem)

* Discover:

  ```bash
  for i in /sys/class/remoteproc/remoteproc*; do echo $(basename $i): $(cat $i/name); done
  ```
* Start/stop/trace:

  ```bash
  echo start > /sys/class/remoteproc/remoteprocX/state
  cat /sys/class/remoteproc/remoteprocX/trace0
  ```
* Common issues:

  * Firmware path wrong → check `/lib/firmware/qcom/` names match DT `firmware-name`.
  * Clocks/regulators not on → supplier errors before start.
  * Crashes after start → inspect `trace0`, check GLINK channels.

### D) RPM (power) / Clocks / Regulators

* **Regulator states:** `regulator_summary` (look for OFF rails during probe).
* **Clock tree:** `clk_summary` (rate/enable\_count/prepare\_count).
* **Runtime PM traps:** Usage count mismatches → enable `CONFIG_PM_DEBUG` and log `pm_runtime` get/put paths (dev\_dbg).

### E) Audio / SLIMbus / WCD codecs (if relevant)

* Pinmux (MI2S/SLIM), codec reset, supplies, BCLK/LRCLK rates.
* Use `aplay -l`, `dmesg | grep asoc`, enable ASoC dapm debug.

### F) USB / HS/SS PHY

* Device/host role via `configfs` (if dual-role).
* Power (VBUS), PHY init, runtime autosuspend quirks: `usbcore.autosuspend=-1` for triage.
* `usbmon`:

  ```bash
  modprobe usbmon
  cat /sys/kernel/debug/usb/usbmon/1u
  ```

---

## 6) Performance/latency on SDM660

* **CPUfreq governor:** `performance` for latency tests, `schedutil` tuned for balance.
* **IRQ affinity:** Move heavy IRQs off CPU0 (housekeeping).
* **I/O scheduler:** For eMMC, try `mq-deadline`/`none`.
* **Memory:** Enable CMA for multimedia; zRAM only if memory-starved (watch CPU).

Quick profiling:

```bash
perf top
perf record -g -- <workload>; perf report
```

---

## 7) Crash capture (kdump) on dev boards

1. Reserve memory: `crashkernel=256M`
2. Configure `kexec-tools`; on panic, collect `/proc/vmcore`
3. Analyze:

```bash
crash vmlinux /path/to/vmcore
# bt, ps, dev -d, files, kmem
```

---

## 8) Typical SDM660 gotchas (pattern → fix)

* **I²C NACKs at probe** → rail off or reset held; confirm in `regulator_summary` & GPIO reset; reduce bus speed.
* **MMC tuning failure** → lock to HS first; verify `vqmmc` 1.8 V switch; check pull-ups and DT caps/timing.
* **Remoteproc won’t start** → wrong `firmware-name` or missing clocks/regulators; check supplier errors and `trace0`.
* **IPA throughput low** → IRQ affinity, GRO on, napi budget; confirm modem side stable.
* **Random oops in ISR** → sleeping in hardirq or stale MMIO; move to threaded IRQ, add memory barriers.

---

## 9) Minimal “what to paste into a lab notebook”

**First run on any failing board:**

```bash
# 1) Capture health
dmesg -T > /tmp/dmesg.txt
cat /proc/interrupts > /tmp/irqs.txt
cat /sys/kernel/debug/clk/clk_summary > /tmp/clk.txt
cat /sys/kernel/debug/regulator/regulator_summary > /tmp/reg.txt

# 2) If hung, dump stacks
echo t > /proc/sysrq-trigger; echo w > /proc/sysrq-trigger; echo l > /proc/sysrq-trigger

# 3) For a suspect driver 'foo'
echo 'module foo +p' > /sys/kernel/debug/dynamic_debug/control
```

**When you have an oops line with an address:**

```bash
addr2line -e vmlinux 0xffffffff8abc1234
```

---

## 10) Build-time configs worth enabling on SDM660 (dev only)

```
CONFIG_DEBUG_FS=y
CONFIG_MAGIC_SYSRQ=y
CONFIG_DEBUG_INFO_DWARF5=y
CONFIG_KASAN=y            # or KFENCE for low overhead
CONFIG_PROVE_LOCKING=y
CONFIG_PM_DEBUG=y
CONFIG_FTRACE=y
CONFIG_FUNCTION_GRAPH_TRACER=y
# Subsystem debugs
CONFIG_MMC_DEBUG=y
CONFIG_QCOM_RPROC=y, CONFIG_RPMSG_CHAR=y
CONFIG_QCOM_CLK_DEBUG=y (if available)
CONFIG_REGULATOR_DEBUG=y (if available)
```

---

### One-liner interview pitch (SDM660 flavor)

> “On SDM660 I boot with `console=ttyMSM0 earlycon initcall_debug nokaslr` and keep `debugfs` mounted. For panics I symbolize with the matching `vmlinux`/`.ko`. For probe issues I verify DT match, then power (RPM/regulator\_summary), clocks (clk\_summary), pinctrl, and the bus (I²C/SPI) while turning on dynamic-debug in the driver. For hangs I dump SysRq stacks, run function-graph tracing, and enable lockdep/RCU stall detect. For subsystems I use `/sys/class/remoteproc/*` and `trace0` for SLPI/ADSP, IPA stats for rmnet, and MMC debugfs for SDHCI. I change one variable at a time and document before/after.”

If you want, I can turn this into a **one-page cheat sheet** or a **canvas you can print** with the exact commands grouped by subsystem.
