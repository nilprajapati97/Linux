Done â€” I created a full, ready-to-read driver file in the canvas titled **"My Uart Driver Full Example"**. It contains a complete out-of-tree platform UART module that demonstrates:

* platform resource mapping (MMIO) and DT matching
* IRQ registration & top-half handler (reads UART registers)
* bottom-half workqueue processing (consumes kfifo and logs)
* a simple char device so you can read received bytes from userspace
* proper use of devm APIs and cleanup

Open the canvas to see the full C source.
==========================================================================================================
/*
 * my_uart.c - Example Linux platform UART driver (out-of-tree module)
 *
 * Features demonstrated:
 *  - Platform driver with device-tree binding
 *  - Resource mapping (MMIO) via devm_ioremap_resource
 *  - IRQ registration (devm_request_irq) using DT interrupt spec
 *  - Top-half: minimal IRQ handler that reads device registers
 *  - Bottom-half: workqueue worker for heavier processing
 *  - Simple kfifo-based char interface for userspace to read received bytes
 *  - Proper device teardown with devm helpers
 *
 * NOTE: This example is intentionally simplified and not a replacement for
 * real serial core drivers (like 8250/serial_core). It's a teaching example
 * that focuses on IRQ/GIC handling and typical platform driver wiring.
 */

#include <linux/module.h>
#include <linux/platform_device.h>
#include <linux/of_device.h>
#include <linux/interrupt.h>
#include <linux/io.h>
#include <linux/errno.h>
#include <linux/slab.h>
#include <linux/kfifo.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/uaccess.h>
#include <linux/workqueue.h>
#include <linux/wait.h>
#include <linux/poll.h>

#define DRIVER_NAME "my_uart" 
#define MYUART_FIFO_SIZE 4096

/* Example UART register offsets (very simplified) */
#define UART_RBR 0x00  /* Receiver Buffer (read) */
#define UART_THR 0x00  /* Transmit Holding Register (write) */
#define UART_IER 0x04  /* Interrupt Enable Register */
#define UART_IIR 0x08  /* Interrupt ID / Status */
#define UART_LSR 0x14  /* Line Status Register */

/* LSR bits (simplified) */
#define LSR_DATA_READY 0x01

struct myuart_dev {
    struct device *dev;
    void __iomem *mmio;
    int irq;

    /* FIFO to hold incoming bytes read by IRQ handler */
    struct kfifo rx_fifo;
    spinlock_t fifo_lock; /* protects kfifo */

    /* bottom-half work to process the FIFO */
    struct work_struct rx_work;

    /* simple char device to expose data to userspace */
    dev_t devt;
    struct cdev cdev;
    struct class *cls;
    wait_queue_head_t read_wait;
};

static inline u8 myuart_readb(struct myuart_dev *m, unsigned int off)
{
    return readb(m->mmio + off);
}

static inline void myuart_writeb(struct myuart_dev *m, unsigned int off, u8 v)
{
    writeb(v, m->mmio + off);
}

/* bottom-half worker: here we simply consume kfifo and print to kernel log
 * (in real driver you'd hand bytes to tty layer or line discipline) */
static void myuart_rx_work_fn(struct work_struct *work)
{
    struct myuart_dev *m = container_of(work, struct myuart_dev, rx_work);
    unsigned char buf[256];
    unsigned int copied;

    while (true) {
        spin_lock(&m->fifo_lock);
        copied = kfifo_out(&m->rx_fifo, buf, sizeof(buf));
        spin_unlock(&m->fifo_lock);

        if (!copied)
            break;

        /* process bytes */
        pr_info("%s: processing %u bytes\n", DRIVER_NAME, copied);
        /* For demonstration, print them as hex (don't do this on high data rates) */
        print_hex_dump(KERN_INFO, DRIVER_NAME ": rx: ", DUMP_PREFIX_OFFSET, 16, 1, buf, copied, false);

        /* Wake any readers waiting on the char device */
        wake_up_interruptible(&m->read_wait);
    }
}

/* top-half IRQ: read available bytes from UART and push into kfifo quickly */
static irqreturn_t myuart_irq_handler(int irq, void *dev_id)
{
    struct myuart_dev *m = dev_id;
    unsigned long flags;
    int handled = 0;

    /* Loop while data ready (level-triggered: read until cleared) */
    while (myuart_readb(m, UART_LSR) & LSR_DATA_READY) {
        u8 c = myuart_readb(m, UART_RBR);
        spin_lock_irqsave(&m->fifo_lock, flags);
        if (!kfifo_is_full(&m->rx_fifo))
            kfifo_in(&m->rx_fifo, &c, 1);
        else
            pr_warn_ratelimited("%s: rx fifo full, dropping byte\n", DRIVER_NAME);
        spin_unlock_irqrestore(&m->fifo_lock, flags);
        handled = 1;
    }

    if (handled) {
        /* schedule bottom half for heavier processing */
        schedule_work(&m->rx_work);
        return IRQ_HANDLED;
    }

    return IRQ_NONE; /* spurious */
}

/* --- Char device interface to read received data --- */
static ssize_t myuart_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)
{
    struct myuart_dev *m = file->private_data;
    unsigned int copied;
    int ret;

    if (kfifo_is_empty(&m->rx_fifo)) {
        if (file->f_flags & O_NONBLOCK)
            return -EAGAIN;

        /* wait until data available */
        ret = wait_event_interruptible(m->read_wait, !kfifo_is_empty(&m->rx_fifo));
        if (ret)
            return ret;
    }

    spin_lock(&m->fifo_lock);
    copied = kfifo_out(&m->rx_fifo, buf, min(count, (size_t)kfifo_len(&m->rx_fifo)));
    spin_unlock(&m->fifo_lock);

    if (copy_to_user(buf, buf, copied))
        return -EFAULT;

    return copied;
}

static unsigned int myuart_poll(struct file *file, poll_table *wait)
{
    struct myuart_dev *m = file->private_data;
    unsigned int mask = 0;

    poll_wait(file, &m->read_wait, wait);
    if (!kfifo_is_empty(&m->rx_fifo))
        mask |= POLLIN | POLLRDNORM;

    return mask;
}

static int myuart_open(struct inode *inode, struct file *file)
{
    struct myuart_dev *m = container_of(inode->i_cdev, struct myuart_dev, cdev);
    file->private_data = m;
    return 0;
}

static const struct file_operations myuart_fops = {
    .owner = THIS_MODULE,
    .read = myuart_read,
    .open = myuart_open,
    .poll = myuart_poll,
};

/* Platform driver probe and remove */
static int myuart_probe(struct platform_device *pdev)
{
    struct myuart_dev *m;
    struct resource *res;
    int ret;

    m = devm_kzalloc(&pdev->dev, sizeof(*m), GFP_KERNEL);
    if (!m)
        return -ENOMEM;

    m->dev = &pdev->dev;

    /* Map MMIO */
    res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
    if (!res) {
        dev_err(&pdev->dev, "no MMIO resource\n");
        return -ENODEV;
    }

    m->mmio = devm_ioremap_resource(&pdev->dev, res);
    if (IS_ERR(m->mmio))
        return PTR_ERR(m->mmio);

    /* Get IRQ from DT / platform resource */
    m->irq = platform_get_irq(pdev, 0);
    if (m->irq < 0) {
        dev_err(&pdev->dev, "no IRQ resource\n");
        return -ENODEV;
    }

    /* Initialize FIFO and locks */
    spin_lock_init(&m->fifo_lock);
    if (kfifo_alloc(&m->rx_fifo, MYUART_FIFO_SIZE, GFP_KERNEL)) {
        dev_err(&pdev->dev, "failed to allocate kfifo\n");
        return -ENOMEM;
    }

    INIT_WORK(&m->rx_work, myuart_rx_work_fn);
    init_waitqueue_head(&m->read_wait);

    /* Create a char device so userspace can read bytes - simple approach */
    ret = alloc_chrdev_region(&m->devt, 0, 1, DRIVER_NAME);
    if (ret) {
        dev_err(&pdev->dev, "alloc_chrdev_region failed\n");
        goto err_free_fifo;
    }
    cdev_init(&m->cdev, &myuart_fops);
    m->cdev.owner = THIS_MODULE;
    ret = cdev_add(&m->cdev, m->devt, 1);
    if (ret) {
        dev_err(&pdev->dev, "cdev_add failed\n");
        goto err_unregister_chrdev;
    }
    m->cls = class_create(THIS_MODULE, DRIVER_NAME);
    if (IS_ERR(m->cls)) {
        ret = PTR_ERR(m->cls);
        goto err_cdev_del;
    }
    if (!device_create(m->cls, NULL, m->devt, NULL, DRIVER_NAME)) {
        dev_err(&pdev->dev, "device_create failed\n");
        goto err_class;
    }

    /* Request IRQ (top-half) */
    ret = devm_request_irq(&pdev->dev, m->irq, myuart_irq_handler, 0, DRIVER_NAME, m);
    if (ret) {
        dev_err(&pdev->dev, "request_irq failed: %d\n", ret);
        goto err_device_remove;
    }

    /* Optionally enable UART RX interrupt in device: this is device-specific
     * and for demo we assume writing 0x1 to IER enables RX interrupt */
    myuart_writeb(m, UART_IER, 0x01);

    platform_set_drvdata(pdev, m);
    dev_info(&pdev->dev, "myuart probed: mmio=%p irq=%d devt=%u:%u\n", m->mmio, m->irq,
             MAJOR(m->devt), MINOR(m->devt));
    return 0;

err_device_remove:
    device_destroy(m->cls, m->devt);
err_class:
    class_destroy(m->cls);
err_cdev_del:
    cdev_del(&m->cdev);
err_unregister_chrdev:
    unregister_chrdev_region(m->devt, 1);
err_free_fifo:
    kfifo_free(&m->rx_fifo);
    return ret;
}

static int myuart_remove(struct platform_device *pdev)
{
    struct myuart_dev *m = platform_get_drvdata(pdev);

    /* Disable device interrupts (device-specific). */
    myuart_writeb(m, UART_IER, 0x00);

    /* Ensure work completed and cleanup */
    cancel_work_sync(&m->rx_work);

    device_destroy(m->cls, m->devt);
    class_destroy(m->cls);
    cdev_del(&m->cdev);
    unregister_chrdev_region(m->devt, 1);
    kfifo_free(&m->rx_fifo);

    dev_info(&pdev->dev, "myuart removed\n");
    return 0;
}

static const struct of_device_id myuart_of_match[] = {
    { .compatible = "myvendor,my-uart", },
    { /* sentinel */ }
};
MODULE_DEVICE_TABLE(of, myuart_of_match);

static struct platform_driver myuart_platform_driver = {
    .probe = myuart_probe,
    .remove = myuart_remove,
    .driver = {
        .name = DRIVER_NAME,
        .of_match_table = myuart_of_match,
    },
};

module_platform_driver(myuart_platform_driver);

MODULE_AUTHOR("Example Author <dev@example.com>");
MODULE_DESCRIPTION("Example platform UART driver demonstrating IRQ/GIC flow");
MODULE_LICENSE("GPL v2");
========================================================================================================

Build & test quick guide:

1. Save the driver file into a directory (e.g. `my_uart/`) as `my_uart.c`.
2. Create a simple `Makefile` in the same dir:

   ```
   obj-m += my_uart.o
   KDIR := /lib/modules/$(shell uname -r)/build

   all:
   	$(MAKE) -C $(KDIR) M=$(PWD) modules

   clean:
   	$(MAKE) -C $(KDIR) M=$(PWD) clean
   ```
3. Build:

   ```
   make
   ```
4. Load the module (on a target with the device described in DT or with a platform\_device registered):

   ```
   sudo insmod my_uart.ko
   ```

   If device tree describes the device with compatible `"myvendor,my-uart"`, kernel will bind the driver. Otherwise you can create a platform device from userspace for testing or add a small platform code to register one.
5. Check dmesg:

   ```
   dmesg | tail -n 50
   ```
6. Read incoming bytes (the driver creates `/dev/my_uart`) â€” then `cat /dev/my_uart` or use `poll`/`read` from a test program.

Device Tree fragment example you can add (for your board DTS):

```
&uart0 {
    compatible = "myvendor,my-uart";
    reg = <0x4000 0x1000>; /* replace with actual base/size */
    interrupts = <GIC_SPI 45 IRQ_TYPE_LEVEL_HIGH>;
    interrupt-parent = <&gic>;
};
```

(Adjust the reg base, size, and interrupt spec to your hardware; `GIC_SPI` is your platform's interrupt mapping macro.)

If you want, I can now:

* add the Makefile & DT-binding fragment into the canvas as separate files, and a test `platform_test.c` that registers a platform\_device so you can test on a desktop Linux, **or**
* convert this into a more realistic `tty`-based driver using `serial_core`/`uart_port` infrastructure (more code & complexity).

Which of those would you like next?
